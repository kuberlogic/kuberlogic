// Code generated by go-swagger; DO NOT EDIT.

package cmd

{{ $name := .Name }}
{{ $operations := .Operations }}
import (
	"os"
	"time"

    "github.com/go-chi/chi"
    "github.com/go-chi/chi/middleware"
    "github.com/go-openapi/loads"
    "github.com/jessevdk/go-flags"

    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/app"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/cache"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/config"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/generated/restapi"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/generated/restapi/operations"
	{{- range $index, $op := .Operations }}
        {{ $found := false }}
        {{- range $i, $sop := $operations }}
            {{- if and (gt $i $index ) (eq $op.Package $sop.Package)}}
                {{ $found = true }}
            {{end -}}
        {{ end -}}
        {{- if not $found }}
        api{{ pascalize $op.Package }} "{{$op.GenCommon.TargetImportPath}}/{{ $op.RootPackage }}/operations/{{ $op.Package }}"
        {{end -}}
    {{ end -}}
	"github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/logging"
	apiserverMiddleware "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/net/middleware"
	"github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/internal/security"
	"github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/util/k8s"
	//cloudlinuxv1 "github.com/kuberlogic/kuberlogic/modules/operator/api/v1"
	//"github.com/kuberlogic/kuberlogic/modules/operator/util"
	"k8s.io/client-go/kubernetes"
	k8scheme "k8s.io/client-go/kubernetes/scheme"
)

func Main(args []string) {
    mainLog := logging.WithComponentLogger("main")
    cfg, err := config.InitConfig("kuberlogic", logging.WithComponentLogger("config"))
    if err != nil {
        mainLog.Fatalw("", "error", err)
        os.Exit(1)
    }

    logging.DebugLevel(cfg.DebugLogs)

    swaggerSpec, err := loads.Analyzed(restapi.SwaggerJSON, "")
    if err != nil {
        mainLog.Fatalw("swagger does not loaded", "error", err)
    }

    k8sconf, err := k8s.GetConfig(cfg)
    if err != nil {
        mainLog.Fatalw("could not get config", "error", err)
    }

//    err = cloudlinuxv1.AddToScheme(k8scheme.Scheme)
//    if err != nil {
//        mainLog.Fatalw("could not add to scheme", "error", err)
//    }

//    crdClient, err := util.GetKuberLogicClient(k8sconf)
//    if err != nil {
//        mainLog.Fatalw("could not generate rest client", "error", err)
//    }

    baseClient, err := kubernetes.NewForConfig(k8sconf)
    if err != nil {
        mainLog.Fatalw("could not get base client", "error", err)
    }

    srv := app.New(baseClient, nil, logging.WithComponentLogger("server"))
    api := operations.NewKuberlogicAPI(swaggerSpec)

	{{range .Operations}}
    api.{{ pascalize .Package }}{{ pascalize .Name }}Handler = api{{ pascalize .Package }}.{{ pascalize .Name }}HandlerFunc(srv.{{ pascalize .Name }}Handler)
    {{- end}}
   	//api.BearerAuth = srv.BearerAuthentication
   	api.Logger = logging.WithComponentLogger("api").Infow
    api.ServerShutdown = srv.OnShutdown
	server := {{ .APIPackage }}.NewServer(api)
	defer server.Shutdown()

	parser := flags.NewParser(server, flags.Default)
	parser.ShortDescription = "KuberLogic API"
	parser.LongDescription = "This is a KuberLogic API"
	server.ConfigureFlags()
	for _, optsGroup := range api.CommandLineOptionsGroups {
		_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)
		if err != nil {
			mainLog.Fatalw("could not add group", "error", err)
		}
	}

	if _, err := parser.ParseArgs(args); err != nil {
		code := 1
		if fe, ok := err.(*flags.Error); ok {
			if fe.Type == flags.ErrHelp {
				code = 0
			}
		}
		os.Exit(code)
	}

    h := api.Serve(nil)
	r := chi.NewRouter()
	r.Use(apiserverMiddleware.NewLoggingMiddleware)
    r.Use(middleware.Recoverer)
    r.Use(apiserverMiddleware.NewCorsMiddleware(cfg))

	r.Mount("/", h)

	server.ConfigureAPI()
	server.SetHandler(r)

	server.Port = cfg.HTTPBindPort
	server.Host = cfg.BindHost
    if err := server.Serve(); err != nil {
        mainLog.Fatalw("problem with serve server", "error", err)
    }
}