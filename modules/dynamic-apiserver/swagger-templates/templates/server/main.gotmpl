// Code generated by go-swagger; DO NOT EDIT.

package cmd

{{ $name := .Name }}
{{ $operations := .Operations }}
import (
	"os"
	"time"

    "github.com/getsentry/sentry-go"
    "github.com/go-chi/chi"
    "github.com/go-chi/chi/middleware"
    "github.com/go-openapi/loads"
    "github.com/jessevdk/go-flags"
    errors "github.com/go-openapi/errors"

    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/app"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/cache"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/config"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/generated/restapi"
    "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/generated/restapi/operations"
	{{- range $index, $op := .Operations }}
        {{ $found := false }}
        {{- range $i, $sop := $operations }}
            {{- if and (gt $i $index ) (eq $op.Package $sop.Package)}}
                {{ $found = true }}
            {{end -}}
        {{ end -}}
        {{- if not $found }}
        api{{ pascalize $op.Package }} "{{$op.GenCommon.TargetImportPath}}/{{ $op.RootPackage }}/operations/{{ $op.Package }}"
        {{end -}}
    {{ end -}}
	"github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/logging"
	apiserverMiddleware "github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/net/middleware"
	"github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/pkg/security"
	"github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/util/k8s"
	cloudlinuxv1alpha1 "github.com/kuberlogic/kuberlogic/modules/dynamic-operator/api/v1alpha1"
	"github.com/kuberlogic/kuberlogic/modules/dynamic-apiserver/util/k8s"
	"k8s.io/client-go/kubernetes"
	k8scheme "k8s.io/client-go/kubernetes/scheme"
)

func Main(args []string, version string) {
    mainLog := logging.WithComponentLogger("main")
    cfg, err := config.InitConfig("kuberlogic", logging.WithComponentLogger("config"))
    if err != nil {
        mainLog.Fatalw("", "error", err)
        os.Exit(1)
    }

	// init sentry
	if dsn := cfg.SentryDsn; dsn != "" {
		logging.UseSentry(dsn, version, cfg.DeploymentId)

		// To initialize Sentry's handler, you need to initialize Sentry itself beforehand
		if err := sentry.Init(sentry.ClientOptions{
			Dsn:              dsn,
			AttachStacktrace: true,
			// Set TracesSampleRate to 1.0 to capture 100%
			// of transactions for performance monitoring.
			// We recommend adjusting this value in production,
			TracesSampleRate: 1.0,
		}); err != nil {
			mainLog.Errorw("Sentry initialization failed", "error", err)
		}

		// Flush buffered events before the program terminates.
		defer sentry.Flush(2 * time.Second)
	}

    logging.DebugLevel(cfg.DebugLogs)

    swaggerSpec, err := loads.Analyzed(restapi.SwaggerJSON, "")
    if err != nil {
        mainLog.Fatalw("swagger does not loaded", "error", err)
    }

	err = cloudlinuxv1alpha1.AddToScheme(k8scheme.Scheme)
	if err != nil {
		mainLog.Fatalw("could not add to scheme", "error", err)
	}

    k8sconf, err := k8s.GetConfig(cfg)
    if err != nil {
        mainLog.Fatalw("could not get config", "error", err)
    }

	crdClient, err := k8s.GetKuberLogicClient(k8sconf)
	if err != nil {
		mainLog.Fatalw("could not generate rest client", "error", err)
	}

	baseClient, err := kubernetes.NewForConfig(k8sconf)
	if err != nil {
		mainLog.Fatalw("could not get base client", "error", err)
	}

    srv := app.New(cfg, baseClient, crdClient, logging.WithComponentLogger("server"))
    api := operations.NewKuberlogicAPI(swaggerSpec)
    // Applies when the "x-token" header is set
    api.KeyAuth = func(token string) (*models.Principal, error) {
        if token == os.Getenv("KUBERLOGIC_APISERVER_TOKEN") {
            prin := models.Principal(token)
            return &prin, nil
        }
        api.Logger("Access attempt with incorrect api key auth: %s", token)
        return nil, errors.New(401, "incorrect api key auth")
    }

	{{range .Operations}}
    api.{{ pascalize .Package }}{{ pascalize .Name }}Handler = api{{ pascalize .Package }}.{{ pascalize .Name }}HandlerFunc(srv.{{ pascalize .Name }}Handler)
    {{- end}}
   	//api.BearerAuth = srv.BearerAuthentication
   	api.Logger = logging.WithComponentLogger("api").Infof
    api.ServerShutdown = srv.OnShutdown
	server := {{ .APIPackage }}.NewServer(api)
	defer server.Shutdown()

	parser := flags.NewParser(server, flags.Default)
	parser.ShortDescription = "KuberLogic API"
	parser.LongDescription = "This is a KuberLogic API"
	server.ConfigureFlags()
	for _, optsGroup := range api.CommandLineOptionsGroups {
		_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)
		if err != nil {
			mainLog.Fatalw("could not add group", "error", err)
		}
	}

	if _, err := parser.ParseArgs(args); err != nil {
		code := 1
		if fe, ok := err.(*flags.Error); ok {
			if fe.Type == flags.ErrHelp {
				code = 0
			}
		}
		os.Exit(code)
	}

    h := api.Serve(nil)
	r := chi.NewRouter()
	r.Use(apiserverMiddleware.NewLoggingMiddleware)
    r.Use(middleware.Recoverer)
    r.Use(apiserverMiddleware.NewCorsMiddleware(cfg))
    r.Use(apiserverMiddleware.SentryLogPanic)
    r.Use(apiserverMiddleware.SetSentryRequestScope)

	r.Mount("/", h)

	server.ConfigureAPI()
	server.SetHandler(r)

	server.Port = cfg.HTTPBindPort
	server.Host = cfg.BindHost
    if err := server.Serve(); err != nil {
        mainLog.Fatalw("problem with serve server", "error", err)
    }
}
