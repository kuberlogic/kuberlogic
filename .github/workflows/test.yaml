name: Integration tests

on:
  pull_request:
    branches: [ master ]
  push:
    branches: [ master ]

jobs:
  test:
    if: "!contains(github.event.commits[0].message, '[skip ci]')"
    name: Integration tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        include:
          - type: postgresql
            pg_version: 13

          - type: postgresql
            pg_version: 12

          - type: postgresql
            pg_version: 11

          - type: postgresql
            pg_version: 10

          - type: postgresql
            pg_version: 9.6

          - type: postgresql
            pg_version: 9.5

#          - type: postgresql
#            pg_version: 9.4
#
#          - type: postgresql
#            pg_version: 9.3

          - type: mysql
            my_version: 5.7.31

          - type: mysql
            my_version: 5.7.29

          - type: mysql
            my_version: 5.7.26

          - type: mysql
            my_version: 5.7.24

#         - type: mysql
#            version: 8.0.20
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Setup Git credentials
        run: |
          git config --global url."https://$PRIVATE_GITHUB_TOKEN:x-oauth-basic@github.com/kuberlogic".insteadOf "https://github.com/kuberlogic"
        env:
          PRIVATE_GITHUB_TOKEN: ${{ secrets.PRIVATE_GITHUB_TOKEN }}

      - name: Updating modules onto current operator version
        run: |
          make bump-operator-version BRANCH=${{ github.event.pull_request.head.sha }}
        if: github.event_name == 'pull_request'

      - name: Get dependencies for the apiserver
        working-directory: ./modules/apiserver
        env:
          GOPRIVATE: github.com/kuberlogic/*
        run: |
          go mod download

      - name: Setup Minikube
        uses: manusa/actions-setup-minikube@v2.3.0
        with:
          minikube version: 'v1.19.0'
          kubernetes version: 'v1.20.5'
          github token: ${{ secrets.GITHUB_TOKEN }}

          # It's need for the local usage for the webhook:
          # Turns on aggregator routing requests to endpoints IP rather than cluster IP.
          start args: --extra-config=apiserver.enable-aggregator-routing=true

      - name: Create secret of operator
        run: |
          kubectl create secret docker-registry kuberlogic-registry --docker-server=$REGISTRY_SERVER --docker-username=$REGISTRY_USER --docker-password=$REGISTRY_PASSWORD
        env:
          REGISTRY_SERVER: ${{ secrets.REGISTRY_SERVER }}
          REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}

      - name: PATCH - Create endpoint for deploying (next stage) validate/mutate webhook configuration in enable-aggregator-routing apiserver mode
        working-directory: ./modules/apiserver/tests
        run: |
          make patch-endpoint
          kubectl get endpoints

      - name: Deploy operator
        run: |
          make deploy-requirements
          make deploy

      - name: Setup minio for backup storage
        working-directory: ./modules/apiserver/tests
        run: |
          make deploy-minio

      - name: Waiting ready the pods
        run: |
          kubectl wait --for=condition=Ready pods --all --timeout=5m

      - name: Show pod status
        run: |
          kubectl logs -l app=minio
          docker images
        if: ${{ failure() }}

      - name: Create test bucket (backup storage)
        working-directory: ./modules/apiserver/tests
        run: |
          make create-bucket

      - name: PATCH - Remove operator, creating certs, change endpoint for ability using webhook locally in the tests
        working-directory: ./modules/apiserver/tests
        run: |
          make undeploy-operator generate-local-webhook-certs patch-endpoint
          kubectl get endpoints

      - name: Ensure keycloak pods are running
        run: |
          kubectl wait --for=condition=Ready pods -l app=keycloak --timeout=5m

      - name: Run the tests with coverage
        working-directory: ./modules/apiserver/tests
        run: |
          KUBERLOGIC_AUTH_KEYCLOAK_URL=https://$(kubectl get svc keycloak -o jsonpath='{.spec.clusterIP}'):8443 GODEBUG=x509ignoreCN=0 KUBERLOGIC_KUBECONFIGPATH=${HOME}/.kube/config make coverage-report RUN=/$TYPE
        env:
          KUBERLOGIC_AUTH_PROVIDER: keycloak
          KUBERLOGIC_AUTH_KEYCLOAK_CLIENTID: apiserver
          KUBERLOGIC_AUTH_KEYCLOAK_CLIENT_SECRET: apiserver-secret
          KUBERLOGIC_AUTH_KEYCLOAK_REALM_NAME: kuberlogic_realm
          PG_VERSION: ${{ matrix.pg_version }}
          MY_VERSION: ${{ matrix.my_version }}
          TYPE: ${{ matrix.type }}

      - name: Upload coverage
        run: |
          bash <(curl -s https://codecov.io/bash) -f modules/apiserver/tests/coverage-operator.out -F operator
          bash <(curl -s https://codecov.io/bash) -f modules/apiserver/tests/coverage-apiserver.out -F apiserver
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Show status
        run: |
          kubectl get pod,sts,deploy,svc,cj,job -o yaml
        if: ${{ failure() }}

      - name: Generating logs
        working-directory: ./modules/apiserver/tests
        run: |
          kubectl logs -l name=postgres-operator --tail=-1 > postgres-operator.log
          kubectl logs -l app=mysql-operator -c mysql-operator --tail=-1 > mysql-operator.log
          kubectl describe pod -l name=postgres-operator > postgres-operator.describe.log
          kubectl describe pod -l app=mysql-operator > mysql-operator.describe.log
          kubectl get pod > pods-status.log
          kubectl get endpoints > endpoints.log
          kubectl get services > services.log
          kubectl get kuberlogicservice,kuberlogicbackupschedules,kuberlogicbackuprestores > kuberlogics-services.log
          kubectl describe pod -l app.kubernetes.io/name=mysql > mysql-cluster.describe.log
          kubectl describe pod -l application=spilo > pg-cluster.describe.log
          kubectl logs -l app.kubernetes.io/name=mysql -c mysql --tail=-1 > mysql-cluster.log
          kubectl logs -l application=spilo -c postgres --tail=-1 > pg-cluster.log
        if: ${{ always() }}
        continue-on-error: true

      - name: Archive logs
        uses: actions/upload-artifact@v2
        with:
          name: ${{ matrix.type }}-${{ matrix.pg_version }}${{ matrix.my_version }}-logs
          path: |
            ./modules/apiserver/tests/*.log
        if: ${{ always() }}
