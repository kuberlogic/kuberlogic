name: Integration tests

on:
  pull_request:
    branches: [ master ]

jobs:
  test:
    if: "!contains(github.event.commits[0].message, '[skip ci]')"
    name: Integration tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        include:
          - type: postgresql
            pg_version: 13

#          - type: postgresql
#            pg_version: 12

#          - type: postgresql
#            pg_version: 11

#          - type: postgresql
#            pg_version: 10

#          - type: postgresql
#            pg_version: 9.6

#          - type: postgresql
#            pg_version: 9.5

#          - type: postgresql
#            pg_version: 9.4
#
#          - type: postgresql
#            pg_version: 9.3

#          - type: mysql
#            my_version: 5.7.31

#          - type: mysql
#            my_version: 5.7.29

#          - type: mysql
#            my_version: 5.7.26

#          - type: mysql
#            my_version: 5.7.24

#         - type: mysql
#            version: 8.0.20
    steps:
      - uses: azure/setup-helm@v1
        with:
          version: v3.4.2
      - uses: actions/setup-go@v2
        with:
          go-version: '1.16.0'
      - name: Checkout
        uses: actions/checkout@v2

      - name: Setup Minikube
        uses: manusa/actions-setup-minikube@v2.3.0
        with:
          minikube version: 'v1.19.0'
          kubernetes version: 'v1.20.5'
          github token: ${{ secrets.GITHUB_TOKEN }}

          # It's need for the local usage for the webhook:
          # Turns on aggregator routing requests to endpoints IP rather than cluster IP.
          start args: --extra-config=apiserver.enable-aggregator-routing=true

      - name: Configure logs
        working-directory: ./modules/apiserver/tests
        run: |
          echo Your testid label value is $GITHUB_RUN_ID
          make configure-logs
        env:
          LOGZ_IO_TOKEN: ${{ secrets.LOGZ_IO_TOKEN }}
          LOGZ_IO_LISTENER: ${{ secrets.LOGZ_IO_LISTENER }}

      - name: fake loadbalancer service by installing metallb
        run: |
          helm repo add metallb https://metallb.github.io/metallb
          helm install --set "configInline.address-pools[0].name=default,configInline.address-pools[0].protocol=layer2,configInline.address-pools[0].addresses[0]=198.51.100.0/24" metallb metallb/metallb

      - name: Set kuberlogic context
        run: |
          kubectl config set-context --current --namespace=kuberlogic

      - name: Build installer
        run: |
          make installer-build

      - name: Run installer
        working-directory: ./modules/installer
        run: |
          ./kuberlogic-installer install all -c t.yaml

      - name: Setup minio & create bucket for backup storage
        working-directory: ./modules/apiserver/tests
        run: |
          make deploy-minio create-bucket

      - name: PATCH - Uninstall operator, creating certs, change endpoint for ability using webhook locally in the tests
        working-directory: ./modules/apiserver/tests
        run: |
          helm uninstall kuberlogic-apiserver
          helm uninstall kuberlogic-operator
          make generate-local-webhook-certs patch-endpoint
          kubectl get endpoints, pods

      - name: Run the tests with coverage
        working-directory: ./modules/apiserver/tests
        run: |
           KUBERLOGIC_KUBECONFIGPATH=${HOME}/.kube/config make coverage-report RUN=/$TYPE
        env:
          GODEBUG: x509ignoreCN=0
          PG_VERSION: ${{ matrix.pg_version }}
          MY_VERSION: ${{ matrix.my_version }}
          TYPE: ${{ matrix.type }}

      - name: Upload coverage
        run: |
          bash <(curl -s https://codecov.io/bash) -f modules/apiserver/tests/coverage-operator.out -F operator
          bash <(curl -s https://codecov.io/bash) -f modules/apiserver/tests/coverage-apiserver.out -F apiserver
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Show status
        run: |
          kubectl get pod,sts,deploy,svc,cj,job -o yaml --all-namespaces
          helm ls --all-namespaces --all
        if: ${{ failure() }}

      - name: Generating logs
        working-directory: ./modules/apiserver/tests
        run: |
          kubectl logs -l app.kubernetes.io/instance=kuberlogic-operator --tail=-1 -c manager > kuberlogic-operator.log
          kubectl logs -l app.kubernetes.io/instance=kuberlogic-apiserver --tail=-1 > kuberlogic-apiserver.log

          kubectl get pod --all-namespaces > pods-status.log
          kubectl get secrets --all-namespaces > secrets.log
          kubectl get endpoints --all-namespaces > endpoints.log
          kubectl get services --all-namespaces > services.log
          kubectl describe kuberlogicservice --all-namespaces > kuberlogic.describe.log

          kubectl logs -l app.kubernetes.io/instance=postgres-operator --tail=-1 > postgres-operator.log
          kubectl logs -l app=mysql-operator -c operator --tail=-1 > mysql-operator.log
          kubectl describe pod -l app.kubernetes.io/instance=postgres-operator > postgres-operator.describe.log
          kubectl describe pod -l app=mysql-operator > mysql-operator.describe.log
          kubectl describe pod -l app.kubernetes.io/name=kuberlogic-alertmanager > alertmanager.describe.log

          kubectl logs -l app.kubernetes.io/name=kube-state-metrics -c kube-state-metrics > kube-state-metrics.logs
          kubectl logs -l app.kubernetes.io/name=kube-state-metrics -c kube-rbac-proxy > kube-rbac-proxy.kube-state-metrics.logs
          kubectl get kuberlogicservice,kuberlogicbackupschedules,kuberlogicbackuprestores --all-namespaces > kuberlogics-services.log
          kubectl describe pod -l app.kubernetes.io/name=mysql --all-namespaces > mysql-cluster.describe.log
          kubectl describe pod -l application=spilo --all-namespaces > pg-cluster.describe.log
          kubectl logs -l app.kubernetes.io/name=mysql -c mysql --tail=-1 > mysql-cluster.log
          kubectl logs -l application=spilo -c postgres --tail=-1 > pg-cluster.log
        if: ${{ always() }}
        continue-on-error: true

      - name: Archive logs
        uses: actions/upload-artifact@v2
        with:
          name: ${{ matrix.type }}-${{ matrix.pg_version }}${{ matrix.my_version }}-logs
          path: |
            ./modules/apiserver/tests/*.log
        if: ${{ always() }}
