// Code generated by go-swagger; DO NOT EDIT.
package {{ .Package }}

import (
    "context"
    "github.com/go-openapi/runtime/middleware"
    "{{ .GenCommon.TargetImportPath }}/models"
    "{{ .GenCommon.TargetImportPath }}/security"
    "github.com/kuberlogic/operator/modules/apiserver/internal/logging/posthog"
    "github.com/kuberlogic/operator/modules/apiserver/util"
)

func {{ pascalize .Name }}Wrapper(srv Service, next {{ pascalize .Name }}HandlerFunc) (fn {{ pascalize .Name }}HandlerFunc) {
	return func(params {{ pascalize .Name }}Params{{ if .Authorized }}, principal {{ if not ( eq .Principal "interface{}" ) }}*{{ end }}{{ .Principal }}{{ end }}) middleware.Responder {
        {{ if .Authorized }}
        log := srv.GetLogger()
        {{ end }}

        {{ $serviceId := `"*"` }}
        {{ range .Params }}
            {{ if eq .Name "ServiceID"}}

             {{ $serviceId = "params.ServiceID" }}

		    // namespace is always provided as a part of Principal object
		    ns := principal.Namespace
            // check ServiceID param
            _, name, err := util.SplitID(params.ServiceID)
            if err != nil {
                msg := "incorrect service id"
                log.Errorw(msg, "serviceId", params.ServiceID, "error", err)
                return New{{ pascalize $.Name }}BadRequest().WithPayload(&models.Error{
                    Message: msg,
                })
            }
            {{ end }}

            {{/* TODO: figure out how avoid name of endpoints such as serviceAdd */}}
            {{ if eq $.Name "serviceAdd" }}
                // build the ServiceID param
                name := params.{{ pascalize .Name }}.Name
                ns := params.{{ pascalize .Name }}.Ns
                serviceId, err := util.JoinID(ns, *name)
                if err != nil {
                    msg := "incorrect service id"
                    log.Errorw(msg, "name", name, "ns", ns, "error", err)
                    return New{{ pascalize $.Name }}BadRequest().WithPayload(&models.Error{
                        Message: msg,
                    })
                }

                {{ $serviceId = "serviceId" }}
            {{ end }}
        {{ end }}

        {{ if .Authorized}}
        // check auth
        authProvider := srv.GetAuthProvider()
        if authorized, err := authProvider.Authorize(principal.Token, security.{{ pascalize .Name }}Permission, {{ $serviceId }}); err != nil {
            msg := "auth bad request"
            log.Errorw(msg, "permission", security.{{ pascalize .Name }}Permission, "serviceId", {{ $serviceId }}, "error", err)
            return New{{ pascalize .Name }}BadRequest().WithPayload(&models.Error{
               Message: msg,
            })
        } else if !authorized {
            log.Errorw("auth forbidden", "permission", security.{{ pascalize .Name }}Permission, "serviceId", {{ $serviceId }})
            return New{{ pascalize .Name }}Forbidden()
        }
        {{ end }}

        {{ if eq $serviceId "params.ServiceID" }}
        // cluster should exists
        service, found, err := srv.LookupService(ns, name)
        if !found {
            msg := "service not found"
            log.Errorw(msg, "error", err)
            return New{{ pascalize $.Name }}BadRequest().WithPayload(&models.Error{
                Message: msg,
            })
        } else if err != nil {
            msg := "error getting service"
            log.Errorw(msg, "error", err)
            return New{{ pascalize $.Name }}ServiceUnavailable().WithPayload(&models.Error{
                Message: msg,
            })
        }

        params.HTTPRequest = params.HTTPRequest.WithContext(
            context.WithValue(params.HTTPRequest.Context(), "service", service))

        {{ end }}

        {{ if not (eq "<nil>" (printf "%T" (index .Extensions "x-posthog")))}}
        // enqueue data to posthog
        posthogMsg := posthog.NewMessage("{{ dasherize .Name}}")
        {{ range index .Extensions "x-posthog" -}}
        {{/* TODO: now condition is not best way to check dereference (nil pointer) exception
            the main problem is leaked abstration to the swagger spec: there located go code "as is" for condition
            need to figure out how to deal with it
         */}}
        {{- if .condition }}
        if {{ .condition }}{
            posthogMsg.With("{{ .key }}", params.{{ .value }})
        }
        {{ else -}}
        posthogMsg.With("{{ .key }}", params.{{ .value }})
        {{ end -}}
        {{ end -}}
        if perr := posthogMsg.Create(); perr != nil {
            msg := "could not enqueue posthog message"
            log.Errorw(msg, "error", perr)
            return New{{ pascalize $.Name }}ServiceUnavailable().WithPayload(&models.Error{
                Message: msg,
            })
        }
        {{ end }}

		return next(params{{ if .Authorized }}, principal{{ end }})
	}
}